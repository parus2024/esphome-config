addressable_lambda: # @krym_parus
  name: "Moving Fixed Area + Random Twinkle"
  update_interval: 20ms
  lambda: |-
    using namespace esphome;

    static int center = 0;  // текущий центр области
    int target = id(led_count);  // ваш target, замените на нужное значение
    const int tail_length = 60;
    const int extra_range = 60;

    // Массив яркости для плавного включения вне основной области
    static float extra_brightness[extra_range] = {0};

    // Шаг яркости за 20ms для плавного включения вне основной области
    const float step = 1.0f / 50.0f;  // 50 шагов по 20ms = 1 секунда

    // Плавно двигаем центр к цели
    if (center < target) {
      center++;
    } else if (center > target) {
      center--;
    }

    // Выключаем все диоды
    it.all() = Color(0, 0, 0);

    // Вычисляем границы основной области
    int start = center - tail_length / 2;
    int end = start + tail_length;

    if (start < 0) {
      start = 0;
      end = tail_length;
    }
    if (end > it.size()) {
      end = it.size();
      start = end - tail_length;
      if (start < 0) start = 0;
    }

    // Заливаем основную область цветом current_color
    for (int i = start; i < end; i++) {
      it[i] = current_color;
    }

    // Плавное включение вне основной области
    for (int i = 0; i < extra_range && i < it.size(); i++) {
      bool in_main_area = (i >= start && i < end);

      if (!in_main_area) {
        const int THRESHOLD = 100;  /* сюда вставьте нужное число (расстояние) при котором вкл\выкл 60 светодиодов */
        if (target < THRESHOLD) {
          extra_brightness[i] += step;
          if (extra_brightness[i] > 1.0f) extra_brightness[i] = 1.0f;
        } else {
          extra_brightness[i] -= step;
          if (extra_brightness[i] < 0.0f) extra_brightness[i] = 0.0f;
        }

        Color add_color = Color(
          (uint8_t)(current_color.r * extra_brightness[i]),
          (uint8_t)(current_color.g * extra_brightness[i]),
          (uint8_t)(current_color.b * extra_brightness[i])
        );
        it[i] = add_color;
      }
    }

    // --- Random Twinkle поверх ---

    // Структура для хранения состояния twinkle каждого диода
    struct TwinkleState {
      uint32_t start_time_ms;
      bool active;
      uint32_t color;
    };
    static TwinkleState twinkle_states[214] = {};

    auto now = millis();

    // Функция генерации случайного цвета
    auto random_color = []() -> Color {
      uint8_t r = random(0, 256);
      uint8_t g = random(0, 256);
      uint8_t b = random(0, 256);
      return Color(r, g, b);
    };

    // Параметр: twinkle только на каждом третьем диоде
    static const int twinkle_step = 5;

    // Получаем длительность twinkle из глобальной переменной
    // (Обязательно объявите в YAML globals: twinkle_duration_ms)
    uint32_t twinkle_duration = id(twinkle_duration_ms);
    uint32_t half_duration = twinkle_duration / 2;

    for (int i = 0; i < it.size(); i++) {
      // Пропускаем диоды, не кратные twinkle_step БЛОК ОТКЛЮЧЕН
    //  if (i % twinkle_step != 0) {
    //    twinkle_states[i].active = false;
    //    continue;
    //  }

      // Получаем текущий цвет диода
      auto cview = it[i];
      Color c = cview.get();

      // Вычисляем яркость как максимум из RGB, нормируем к 0..1
      float brightness = max(max(c.r, c.g), c.b) / 255.0f;

      // Если яркость > 0 — диод занят, twinkle не рисуем
      if (brightness > 0.01f) {
        twinkle_states[i].active = false;
        continue;
      }

      // Диод свободен — проверяем twinkle
      if (!twinkle_states[i].active) {
        if (random(100) < 0.02) {  // 0,02% вероятность запуска twinkle
          twinkle_states[i].active = true;
          twinkle_states[i].start_time_ms = now;
          Color col = random_color();
          // Сохраняем цвет в uint32_t (RGB)
          twinkle_states[i].color = (col.r << 16) | (col.g << 8) | col.b;
        }
      }

      if (twinkle_states[i].active) {
        uint32_t elapsed = now - twinkle_states[i].start_time_ms;

        if (elapsed > twinkle_duration) {
          // Twinkle завершился — выключаем диод
          twinkle_states[i].active = false;
          it[i] = Color(0, 0, 0);
        } else {
          float twinkle_brightness;

          // Зажигание: яркость растёт от 0 до 1 в первой половине времени
          if (elapsed < half_duration) {
            twinkle_brightness = (float)elapsed / half_duration;
          } else {
            // Затухание: яркость падает от 1 до 0 во второй половине времени
            twinkle_brightness = 1.0f - (float)(elapsed - half_duration) / half_duration;
          }

          // Восстанавливаем RGB из сохранённого цвета
          uint8_t r = (twinkle_states[i].color >> 16) & 0xFF;
          uint8_t g = (twinkle_states[i].color >> 8) & 0xFF;
          uint8_t b = (twinkle_states[i].color) & 0xFF;

          // Масштабируем цвет по яркости
          r = (uint8_t)(r * twinkle_brightness);
          g = (uint8_t)(g * twinkle_brightness);
          b = (uint8_t)(b * twinkle_brightness);

          Color twinkle_color(r, g, b);

          // Рисуем twinkle поверх
          it[i] = twinkle_color;
        }
      }
    }
