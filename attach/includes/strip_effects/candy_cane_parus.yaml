addressable_lambda:
  name: "Candy Cane Parus"
  update_interval: 50ms
  lambda: |-
    static int position = 0;
    const int width = it.size();

    // Настройки диапазонов
    const int MIN_SPEED = 1;      // Минимальная скорость (пикселей за шаг)
    const int MAX_SPEED = 5;      // Максимальная скорость (пикселей за шаг)
    const int MIN_SEGMENT_SIZE = 5;  // Минимальная длина отрезка
    const int MAX_SEGMENT_SIZE = 30; // Максимальная длина отрезка

    // Получаем значения со слайдеров
    const uint8_t SPEED = static_cast<uint8_t>(id(effect_speed).state);      // 0–255
    const uint8_t SEGMENT_SIZE_SLIDER = static_cast<uint8_t>(id(effect_scale).state); // 0–100
    const uint8_t INTENSITY = static_cast<uint8_t>(id(effect_intensity).state); // 0–255

    // Нормализуем значения
    int speed = MIN_SPEED + (SPEED * (MAX_SPEED - MIN_SPEED) / 255);  // Скорость: 1–5 пикселей за шаг
    int segment_size = MIN_SEGMENT_SIZE + (SEGMENT_SIZE_SLIDER * (MAX_SEGMENT_SIZE - MIN_SEGMENT_SIZE) / 100);  // Длина отрезков: 5–30 пикселей

    static Color segment_color = Color::random_color();
    static int segment_position = 0;

    // Коэффициент смешивания с белым (0.0 - полностью белый, 1.0 - полностью цвет)
    float color_intensity = INTENSITY / 255.0;

    // Смешиваем цвет с белым в зависимости от интенсивности
    Color white(255, 255, 255);
    uint8_t r = static_cast<uint8_t>(segment_color.red * color_intensity + white.red * (1.0 - color_intensity));
    uint8_t g = static_cast<uint8_t>(segment_color.green * color_intensity + white.green * (1.0 - color_intensity));
    uint8_t b = static_cast<uint8_t>(segment_color.blue * color_intensity + white.blue * (1.0 - color_intensity));
    Color mixed_color(r, g, b);

    // Сдвигаем все пиксели влево на скорость
    for (int i = 0; i < width - speed; i++) {
      it[i] = it[i + speed].get();
    }

    // Заполняем новые пиксели текущим цветом
    for (int i = width - speed; i < width; i++) {
      it[i] = mixed_color;
    }

    // Увеличиваем позицию внутри отрезка
    segment_position += speed;

    // Если отрезок закончился, меняем цвет
    if (segment_position >= segment_size) {
      segment_color = Color::random_color();
      segment_position = 0;
    }
