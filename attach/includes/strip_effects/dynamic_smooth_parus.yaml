addressable_lambda:
  name: "Dinamic Smooth Parus"
  update_interval: 30ms
  lambda: |-
    static uint32_t step = 0;
    const uint8_t SPEED = id(effect_speed).state;      // 0–255: скорость изменения
    const uint8_t SCALE = id(effect_scale).state;     // 0–100: масштаб эффекта (размер цветовых участков)
    const uint8_t INTENSITY = id(effect_intensity).state; // 0–255: яркость

    // Масштаб участков: 1.0–7.0
    float scale_factor = 1.0 + (SCALE / 20.0);

    // Скорость: минимальная скорость -> минимальная, максимальная скорость -> максимальная
    float speed_factor = 1.0 + (SPEED / 6.8); // Диапазон: 1.0–41.25

    for (int i = 0; i < it.size(); i++) {
        // Рассчитываем позицию с учетом масштаба и скорости
        float pos = (i * scale_factor) + (step * speed_factor / 10.0);
        uint8_t hue = (uint8_t)((int)pos % 256);

        // Преобразование HSV в RGB с учетом интенсивности
        float h = hue / 255.0 * 360.0;
        float s = 1.0;
        float v = 1.0;

        float c = v * s;
        float x = c * (1 - fabs(fmod(h / 60.0, 2) - 1));
        float m = v - c;

        float r, g, b;
        if (h < 60) {
            r = c; g = x; b = 0;
        } else if (h < 120) {
            r = x; g = c; b = 0;
        } else if (h < 180) {
            r = 0; g = c; b = x;
        } else if (h < 240) {
            r = 0; g = x; b = c;
        } else if (h < 300) {
            r = x; g = 0; b = c;
        } else {
            r = c; g = 0; b = x;
        }

        r = (r + m) * 255 * (INTENSITY / 255.0);
        g = (g + m) * 255 * (INTENSITY / 255.0);
        b = (b + m) * 255 * (INTENSITY / 255.0);

        it[i] = Color((uint8_t)r, (uint8_t)g, (uint8_t)b);
    }

    step += 1;
