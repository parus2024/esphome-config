addressable_lambda:
  name: Fireworks Parus
  update_interval: 30ms
  lambda: |-
    // Получаем значения со слайдеров
    const uint8_t SPEED = static_cast<uint8_t>(id(effect_speed).state);      // 0–255
    const uint8_t SCALE = static_cast<uint8_t>(id(effect_scale).state);         // 0–100
    const uint8_t INTENSITY = 255 - static_cast<uint8_t>(id(effect_intensity).state); // 0–255
    const uint8_t INT = std::max(static_cast<uint8_t>(20), INTENSITY);        // минимум 20

    // === РАСЧЁТ ПАРАМЕТРОВ ПО СЛАЙДЕРАМ ===

    // 1. Скорость (effect_speed) влияет на:
    //    - ROCKET_START_VEL (прямая зависимость)
    //    - SCATTER_SPEED (прямая зависимость)
    //    - FADE_DURATION (обратная зависимость)
    const float ROCKET_START_VEL = 1.5f + (float)SPEED * 0.01f;  // 1.5–4.0
    const float SCATTER_SPEED = 1.0f + (float)SPEED * 0.006f;       // 1.0–2.5
    const float FADE_DURATION = 5.0f - (float)SPEED * 0.014f;      // 5.0–1.5 (обратно SPEED)

    // 2. Интенсивность (effect_intensity) влияет на:
    //    - MAX_MINI_ROCKETS (прямая зависимость)
    //    - MINI_ROCKET_TAIL_SIZE (обратная)
    //    - MINI_ROCKET_HEAD_SIZE (обратная)
    //    - ROCKET_HEAD_LEN (обратная)
    const int MAX_MINI_ROCKETS = 4 + (int)((float)INT * 0.12f);           // 4–35
    const int MINI_ROCKET_TAIL_SIZE = 12 - std::min(8, (int)(INT * 0.032f)); // 4–12
    const int MINI_ROCKET_HEAD_SIZE = 3 - std::min(2, (int)(INT * 0.012f));  // 1–3
    const int ROCKET_HEAD_LEN = 3 - std::min(2, (int)(INT * 0.012f));        // 1–3

    // 3. Масштаб (effect_scale) — опционально для общей регулировки
    // Например, можно масштабировать гравитацию:
    const float GRAVITY = -0.02f - (float)SCALE * 0.0002f;  // -0.02…–0.04

    // === НАСТРАИВАЕМЫЕ ПАРАМЕТРЫ === перенесены в зависимость от слайдеров
    //const int ROCKET_HEAD_LEN = 1;  // Длина головы основной ракеты: 1–3
    //const int MINI_ROCKET_HEAD_SIZE = 1;  // Длина головы мини‑ракеты: 1–2
    //const int MINI_ROCKET_TAIL_SIZE = 8;  // Длина хвоста мини‑ракеты: 4–8
    //const int MAX_MINI_ROCKETS = 30;  // Макс. число искр: 8–20
    //const float ROCKET_START_VEL = 2.1f;  // Нач. скорость ракеты: 1.5–2.5
    //const float GRAVITY = -0.02f;  // Ускорение свободного падения: -0.01…–0.03
    //const float SCATTER_SPEED = 1.2f;  // Скорость разлёта искр: 1.0–2.0
    //const float FADE_DURATION = 3.5f;  // Время затухания искр (сек): 2.0–5.0
    const float MIN_EXPLOSION_POS = 0.25f;  // Мин. высота взрыва: 0.1–0.4
    const float MAX_EXPLOSION_POS = 0.75f;  // Макс. высота взрыва: 0.5–0.9


    // ★ НОВЫЕ ПАРАМЕТРЫ ДЛЯ ЭМИССИИ
    const float EMISSION_DURATION = 0.5f;      // Длительность эмиссии (сек)
    const int EMISSION_STEPS = 20;           // Число шагов эмиссии
    const float EMISSION_INTERVAL = EMISSION_DURATION / EMISSION_STEPS;  // Интервал между шагами


    // === ВНУТРЕННИЕ ПЕРЕМЕННЫЕ ===
    static float rocket_pos = 0.0f;
    static float rocket_vel = 0.0f;
    static bool is_exploding = false;
    static float explosion_pos = 0.0f;

    // ★ ФИКСИРУЕМ МАКСИМАЛЬНЫЙ РАЗМЕР МАССИВОВ ДЛЯ КОМПАИЛЯТОРА
    #define MAX_ROCKETS_MAX 50  // Максимальный размер массивов (должен быть >= максимально возможного MAX_MINI_ROCKETS)


    static float mr_pos[MAX_ROCKETS_MAX] = {0};
    static float mr_vel_x[MAX_ROCKETS_MAX] = {0};
    static float mr_vel_y[MAX_ROCKETS_MAX] = {0};
    static bool mr_active[MAX_ROCKETS_MAX] = {false};
    static uint32_t mr_start_time[MAX_ROCKETS_MAX] = {0};
    static esphome::Color mr_color[MAX_ROCKETS_MAX];

    // ★ ДОПОЛНИТЕЛЬНЫЕ ПЕРЕМЕННЫЕ ДЛЯ ЭМИССИИ
    static bool is_emitting = false;           // Флаг: идёт эмиссия?
    static int emitted_count = 0;             // Сколько искр выпущено
    static unsigned long last_emission_time = 0;  // Время последней эмиссии

    uint32_t now = millis();
    int led_count = it.size();

    // 1. Запуск основной ракеты
    if (!is_exploding && rocket_pos == 0.0f) {
      rocket_vel = ROCKET_START_VEL;
      explosion_pos = led_count * (MIN_EXPLOSION_POS +
                       (float)(random() % (int)((MAX_EXPLOSION_POS - MIN_EXPLOSION_POS) * 100)) / 100.0f);
    }

    // 2. Полёт основной ракеты
    if (!is_exploding) {
      rocket_pos += rocket_vel;
      rocket_vel += GRAVITY;

      // Очистка ленты
      for (int i = 0; i < led_count; i++) {
        it[i] = esphome::Color(0, 0, 0, 0.01f);
      }

      // Рисуем основную ракету (белый)
      for (int i = 0; i < ROCKET_HEAD_LEN; i++) {
        int pos = (int)(rocket_pos - i);
        if (pos >= 0 && pos < led_count) {
          it[pos] = esphome::Color(255, 255, 255, 1.0f);
        }
      }

      // Рисуем хвост основной ракеты
      const int ROCKET_TAIL_LEN = 8;
      const float ROCKET_TAIL_FADE_EXP = 1.0f;

      for (int j = 1; j <= ROCKET_TAIL_LEN; j++) {
        int tail_pos = (int)(rocket_pos - ROCKET_HEAD_LEN - j);
        if (tail_pos < 0 || tail_pos >= led_count) continue;


        float t = (float)j / (float)ROCKET_TAIL_LEN;
        float fade_factor = powf(1.0f - t, ROCKET_TAIL_FADE_EXP);
        float final_brightness = fade_factor;

        if (final_brightness < 0.02f) continue;

        int r = (int)(255 * final_brightness);
        int g = (int)(80 * final_brightness);
        int b = 0;
        it[tail_pos] = esphome::Color(r, g, b);
      }

      // Переход в взрыв
      if (rocket_vel < -0.3f || rocket_pos >= explosion_pos) {
        is_exploding = true;
        is_emitting = true;           // ★ Запускаем эмиссию
        emitted_count = 0;          // ★ Сбрасываем счётчик
        last_emission_time = now;   // ★ Фиксируем время начала
      }
    }
    // 3. Взрыв и эмиссия искр
    else {
      bool all_dead = true;

      // ★ ЭМИССИЯ ИСКР: добавляем порциями
      if (is_emitting) {
        unsigned long current_time = now;
        if (current_time - last_emission_time >= EMISSION_INTERVAL * 1000) {
          if (emitted_count < MAX_MINI_ROCKETS) {
            int i = emitted_count;

            mr_active[i] = true;
            mr_pos[i] = rocket_pos;
            mr_start_time[i] = current_time;

            // Случайный цвет
            int r = 0, g = 0, b = 0;
            switch (random() % 6) {
              case 0: r = 255; g = random() % 100; b = random() % 100; break;
              case 1: r = random() % 100; g = 255; b = random() % 100; break;
              case 2: r = random() % 100; g = random() % 100; b = 255; break;
              case 3: r = 255; g = 255; b = random() % 100; break;
              case 4: r = 255; g = random() % 100; b = 255; break;
              case 5: r = random() % 100; g = 255; b = 255; break;
            }
            mr_color[i] = esphome::Color(r, g, b);

            // 1D-разлёт: только вверх или вниз
            float speed = SCATTER_SPEED * (0.8f + (float)(random() % 40) / 100.0f);
            int direction = (random() % 2) == 0 ? +1 : -1;
            mr_vel_y[i] = direction * speed;
            mr_vel_x[i] = 0.0f;

            emitted_count++;
            last_emission_time = current_time;
          }
          else {
            is_emitting = false;  // ★ Все искры выпущены
          }
        }
      }

      // Очистка ленты
      for (int i = 0; i < led_count; i++) {
        it[i] = esphome::Color(0, 0, 0, 0.01f);
      }

      // Обновление и отрисовка искр
      for (int i = 0; i < MAX_MINI_ROCKETS; i++) {
        if (!mr_active[i]) continue;

        // Обновляем позицию
        mr_pos[i] += mr_vel_x[i];
        mr_pos[i] += mr_vel_y[i];

        // Проверка границ (расширили зону жизни) было 10, столо 20
        if (mr_pos[i] < -10.0f || mr_pos[i] > led_count + 10.0f) {
          mr_active[i] = false;
          continue;
        }

        // Расчёт яркости (по времени)
        float elapsed = (now - mr_start_time[i]) / 1000.0f;
        float brightness = 1.0f - (elapsed / FADE_DURATION);
        if (brightness < 0.0f) brightness = 0.0f;

        // Рисуем голову (1 пиксель)
        for (int j = 0; j < MINI_ROCKET_HEAD_SIZE; j++) {
          int head_pos = (int)(mr_pos[i] - j);
          if (head_pos >= 0 && head_pos < led_count) {
            it[head_pos] = esphome::Color(
              mr_color[i].red,
              mr_color[i].green,
              mr_color[i].blue,
              brightness
            );
          }
        }

        // Позиция головы (округление)
        int head_pixel = (int)(mr_pos[i] + 0.5f);
        int move_direction = (mr_vel_y[i] > 0.0f) ? +1 : -1;

        // Рисуем хвост
        for (int j = 1; j <= MINI_ROCKET_TAIL_SIZE; j++) {
          int tail_pos = head_pixel - move_direction * j;

          // Проверка границ
          if (tail_pos < 0 || tail_pos >= led_count) continue;

          // Запрет наложения на голову
          if (tail_pos == head_pixel) continue;

          // Затухание (линейное)
          float t = (float)j / (float)MINI_ROCKET_TAIL_SIZE;
          float fade_factor = 1.0f - t;
          float final_brightness = brightness * fade_factor;

          // Масштабируем цвет
          int r = (int)(mr_color[i].red * final_brightness);
          int g = (int)(mr_color[i].green * final_brightness);
          int b = (int)(mr_color[i].blue * final_brightness);

          it[tail_pos] = esphome::Color(r, g, b);
        }

        // Проверяем, жива ли искра
        if (brightness > 0.1f) {
          all_dead = false;
        }
      }

      // Завершение взрыва
      if (all_dead) {
        is_exploding = false;
        rocket_pos = 0.0f;
        rocket_vel = 0.0f;
      }
    }
