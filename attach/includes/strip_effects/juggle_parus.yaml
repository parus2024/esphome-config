addressable_lambda:
  name: "Juggle Parus"
  update_interval: 10ms
  lambda: |-
    static uint8_t thisindex = 0;
    static uint8_t numdots;
    static uint8_t thisfade;
    static float thisbeat;
    static uint8_t thisdiff;

    static int variant = -1;
    static std::vector<Color> leds(it.size(), Color::BLACK);

    // Получаем значения со слайдеров
    const uint8_t SPEED = static_cast<uint8_t>(id(effect_speed).state);      // 0–255 (скорость движения)
    const uint8_t SCALE = static_cast<uint8_t>(id(effect_scale).state);       // 0–100 (режим)
    const uint8_t INTENSITY = static_cast<uint8_t>(id(effect_intensity).state); // 0–255 (насыщенность/яркость)


    if (initial_run) {
      ESP_LOGD("effect", "Juggle Parus (Fixed Speed)");
    }

    // Настраиваем параметры в зависимости от SCALE
    if (variant != static_cast<int>(SCALE)) {
      if (SCALE > 50) {
        numdots = 4;
        thisfade = 32;
        thisbeat = 12.0;
        thisdiff = 20;
      } else {
        numdots = 2;
        thisfade = 16;
        thisbeat = 8.0;
        thisdiff = 64;
      }
      variant = static_cast<int>(SCALE);
    }

    // Исправленный расчёт скорости: чем больше SPEED, тем медленнее движение
    float speed_factor = (255.0 - SPEED) / 255.0;  // 1.0 → 0.0
    thisbeat = 5.0 + speed_factor * 15.0;               // 20.0 → 5.0

    // Настраиваем насыщенность и яркость через INTENSITY
    uint8_t saturation = 50 + (INTENSITY / 255.0) * 205;  // Диапазон: 50–255
    uint8_t brightness = 50 + (INTENSITY / 255.0) * 205;    // Диапазон: 50–255

    // 1. Затухание всех пикселей
    for (auto &pixel : leds) {
      pixel.r = std::max(0, (int)pixel.r - thisfade);
      pixel.g = std::max(0, (int)pixel.g - thisfade);
      pixel.b = std::max(0, (int)pixel.b - thisfade);
    }

    // 2. Движение шаров
    for (int i = 0; i < numdots; i++) {
      float normalized_beat = thisbeat / 10.0;
      int pos = (int)(it.size() * 0.5 * (1 + sin(2 * M_PI * (millis() / (normalized_beat * 1000.0 + i + numdots)))));
      pos = pos % it.size();

      // Конвертация HSV→RGB
      uint8_t hue = (thisindex + i * thisdiff) % 255;
      float h = hue / 255.0;
      float s = saturation / 255.0;
      float v = brightness / 255.0;

      int i_h = (int)(h * 6);
      float f = h * 6 - i_h;
      float p = v * (1 - s);
      float q = v * (1 - s * f);
      float t = v * (1 - s * (1 - f));

      float r, g, b;
      switch (i_h % 6) {
        case 0: r = v; g = t; b = p; break;
        case 1: r = q; g = v; b = p; break;
        case 2: r = p; g = v; b = t; break;
        case 3: r = p; g = q; b = v; break;
        case 4: r = t; g = p; b = v; break;
        default: r = v; g = p; b = q; break;
      }

      Color color(
        static_cast<uint8_t>(r * 255),
        static_cast<uint8_t>(g * 255),
        static_cast<uint8_t>(b * 255)
      );

      leds[pos] += color;
    }

    // Обновляем индекс цвета
    thisindex += 1;

    // 3. Синхронизация с лентой
    for (int i = 0; i < it.size(); i++) {
      it[i] = leds[i];
    }
