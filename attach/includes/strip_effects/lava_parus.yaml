addressable_lambda:
  name: "Lava Parus"
  update_interval: 30ms
  lambda: |-
    static std::vector<float> positions;
    static std::vector<float> speeds;
    static std::vector<float> sizes;
    static uint8_t hue = 0;

    const uint8_t SPEED = id(effect_speed).state;      // 0–255: скорость движения
    const uint8_t SCALE = id(effect_scale).state;      // 0–100: количество и размер "капель"
    const uint8_t INTENSITY = id(effect_intensity).state; // 0–255: яркость

    // Функция для преобразования HSV в RGB
    auto hsv_to_rgb = [](float h, float s, float v) -> Color {
      if (s <= 0.0) {
        uint8_t val = static_cast<uint8_t>(v * 255);
        return Color(val, val, val);
      }

      h = fmod(h, 360.0); // Убедимся, что h в диапазоне 0-360
      h /= 60.0;
      int i = static_cast<int>(floor(h));
      float f = h - i;
      float p = v * (1.0 - s);
      float q = v * (1.0 - s * f);
      float t = v * (1.0 - s * (1.0 - f));

      uint8_t r, g, b;
      switch (i) {
        case 0: r = static_cast<uint8_t>(v * 255); g = static_cast<uint8_t>(t * 255); b = static_cast<uint8_t>(p * 255); break;
        case 1: r = static_cast<uint8_t>(q * 255); g = static_cast<uint8_t>(v * 255); b = static_cast<uint8_t>(p * 255); break;
        case 2: r = static_cast<uint8_t>(p * 255); g = static_cast<uint8_t>(v * 255); b = static_cast<uint8_t>(t * 255); break;
        case 3: r = static_cast<uint8_t>(p * 255); g = static_cast<uint8_t>(q * 255); b = static_cast<uint8_t>(v * 255); break;
        case 4: r = static_cast<uint8_t>(t * 255); g = static_cast<uint8_t>(p * 255); b = static_cast<uint8_t>(v * 255); break;
        case 5: r = static_cast<uint8_t>(v * 255); g = static_cast<uint8_t>(p * 255); b = static_cast<uint8_t>(q * 255); break;
        default: r = g = b = static_cast<uint8_t>(v * 255);
      }
      return Color(r, g, b);
    };

    if (initial_run) {
        ESP_LOGD("effect", "Lava Parus");
        it.all() = Color::BLACK;

        // Количество "капель" лавы
        uint8_t num_drops = 3 + SCALE / 20; // от 3 до 8 капель
        positions.resize(num_drops);
        speeds.resize(num_drops);
        sizes.resize(num_drops);

        for (uint8_t i = 0; i < num_drops; i++) {
            positions[i] = random(it.size());
            speeds[i] = 0.1 + random(10) / 20.0; // скорость от 0.1 до 0.6
            sizes[i] = 5 + random(10); // размер капли от 5 до 15 светодиодов
        }
    }

    hue += 2; // Увеличиваем шаг изменения цвета для более заметного эффекта

    // Очистка ленты
    it.all() = Color(0, 0, 0);

    // Отрисовка капель
    for (size_t i = 0; i < positions.size(); i++) {
        float pos = positions[i];
        pos += speeds[i] * (SPEED / 50.0); // скорость зависит от слайдера

        // Если капля вышла за пределы ленты, возвращаем её в начало
        if (pos >= it.size()) {
            pos = 0;
        }

        positions[i] = pos;

        // Отрисовка капли
        int start_pos = std::max(0, static_cast<int>(pos) - static_cast<int>(sizes[i]) / 2);
        int end_pos = std::min(static_cast<int>(it.size()) - 1, static_cast<int>(pos) + static_cast<int>(sizes[i]) / 2);

        // Разные оттенки для каждой капли, используем диапазон от красного до желтого
        float current_hue = fmod(hue + i * 30, 360.0);
        Color color = hsv_to_rgb(current_hue, 1.0, 1.0);

        for (int j = start_pos; j <= end_pos; j++) {
            // Плавное затухание к краям капли
            float dist = fabs(j - pos);
            float intensity = 1.0 - (dist / (sizes[i] / 2));
            if (intensity > 0) {
                uint8_t r = static_cast<uint8_t>(color.red * intensity * (INTENSITY / 255.0));
                uint8_t g = static_cast<uint8_t>(color.green * intensity * (INTENSITY / 255.0));
                uint8_t b = static_cast<uint8_t>(color.blue * intensity * (INTENSITY / 255.0));
                it[j] = Color(r, g, b);
            }
        }
    }
