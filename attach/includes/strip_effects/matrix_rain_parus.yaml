addressable_lambda:
  name: Matrix Rain Parus
  update_interval: 40ms
  lambda: |-
    // КОНСТАНТЫ
    const int NUM_DROPS = 8;
    const int MAX_GLOBAL_SPEED = 5;  // Макс. вклад слайдера (общий ускоритель)
    const int MIN_LEN = 1;
    const int MAX_LEN = 8;
    const int SPAWN_RATE = 15;       // Чем меньше — чаще появление

    // СТРУКТУРА КАПЛИ
    static struct {
      int y;           // Позиция головы (пиксель)
      int len;          // Длина отрезка
      int base_vy;      // Базовая скорость капли (индивидуальная)
      int global_vy;    // Вклад слайдера (общий для всех)
      bool active;       // Активна?
    } drops[NUM_DROPS];

    // СЛАЙДЕРЫ
    int speed_val = id(effect_speed).state;   // 0–255
    int scale_val = id(effect_scale).state;     // 0–255
    int bright = id(effect_intensity).state;     // 0–255

    // 1. ИНИЦИАЛИЗАЦИЯ
    if (initial_run) {
      for (int i = 0; i < NUM_DROPS; i++) {
        drops[i].active = false;
      }
    }

    // 2. РАСЧЁТ ОБЩЕЙ СКОРОСТИ (вклад слайдера)
    int global_speed = min(speed_val / 50, MAX_GLOBAL_SPEED);  // 0–5

    // 3. ДВИЖЕНИЕ И ОТРИСОВКА
    for (int i = 0; i < NUM_DROPS; i++) {
      if (drops[i].active) {
        // Общая скорость капли: индивидуальная база + общий ускоритель
        int total_vy = drops[i].base_vy + global_speed;

        drops[i].y -= total_vy;  // Движение к нулю (вниз)

        // Отрисовка отрезка: от головы вниз
        for (int j = 0; j < drops[i].len; j++) {
          int pix = drops[i].y - j;
          if (pix >= 0 && pix < it.size()) {
            it[pix].set(esphome::Color(0, bright, 0));  // Зелёный
          }
        }

        // Удаление за нижним краем
        if (drops[i].y < 0) {
          drops[i].active = false;
        }
      }
    }

    // 4. РОЖДЕНИЕ НОВЫХ КАПЕЛЬ (с индивидуальной скоростью)
    int chance = scale_val / SPAWN_RATE;
    if ((rand() % 100) < chance) {
      for (int i = 0; i < NUM_DROPS; i++) {
        if (!drops[i].active) {
          drops[i].y = it.size() - 1;                  // Старт вверху
          drops[i].len = (rand() % (MAX_LEN - MIN_LEN + 1)) + MIN_LEN;
          drops[i].base_vy = (rand() % 3) + 1;       // Индивидуальная база: 1–3 пикселя
          drops[i].global_vy = global_speed;           // Запоминаем общий ускоритель
          drops[i].active = true;
          break;
        }
      }
    }

    // 5. ОЧИСТКА НЕЗАНЯТЫХ ПИКСЕЛЕЙ
    for (int i = 0; i < it.size(); i++) {
      bool occupied = false;
      for (int j = 0; j < NUM_DROPS; j++) {
        if (drops[j].active) {
          for (int k = 0; k < drops[j].len; k++) {
            if (drops[j].y - k == i) {
              occupied = true;
              break;
            }
          }
        }
      }
      if (!occupied) {
        it[i].set(esphome::Color(0, 0, 0));
      }
    }
