addressable_lambda:
  name: "Rainbow Parus"
  update_interval: 20ms
  lambda: |-
    // --- Настройки диапазонов (можно менять вручную) ---
    // Минимальная и максимальная скорость (0.01–0.5 для плавности)
    const float MIN_SPEED = 0.01;
    const float MAX_SPEED = 0.1;

    // Минимальное и максимальное растяжение (0.5–3.0 для умеренного эффекта)
    const float MIN_STRETCH = 0.5;
    const float MAX_STRETCH = 5.0;

    // --- Получаем значения со слайдеров ---
    const uint8_t RAINBOW_SPEED = static_cast<uint8_t>(id(effect_speed).state);      // 0–255
    const uint8_t RAINBOW_STRETCH = static_cast<uint8_t>(id(effect_scale).state);    // 0–255
    const uint8_t RAINBOW_SATURATION = static_cast<uint8_t>(id(effect_intensity).state); // 0–255

    // --- Нормализуем значения с учётом ручных диапазонов ---
    // Скорость: линейное отображение 0–255 → MIN_SPEED–MAX_SPEED
    float speed = MIN_SPEED + (RAINBOW_SPEED / 255.0) * (MAX_SPEED - MIN_SPEED);

    // Растяжение: линейное отображение 0–255 → MIN_STRETCH–MAX_STRETCH
    float stretch = MIN_STRETCH + (RAINBOW_STRETCH / 255.0) * (MAX_STRETCH - MIN_STRETCH);

    // Насыщенность: 0.0–1.0
    float saturation = RAINBOW_SATURATION / 255.0;

    // --- Лямбда-функция для конвертации HSV в RGB ---
    auto hsv_to_rgb = [](float h, float s, float v) -> Color {
      if (s == 0) {
        uint8_t val = static_cast<uint8_t>(v * 255);
        return Color(val, val, val);
      }

      h *= 6.0;
      int i = static_cast<int>(floor(h));
      float f = h - i;
      float p = v * (1.0 - s);
      float q = v * (1.0 - s * f);
      float t = v * (1.0 - s * (1.0 - f));

      uint8_t r, g, b;
      switch (i) {
        case 0: r = static_cast<uint8_t>(v * 255); g = static_cast<uint8_t>(t * 255); b = static_cast<uint8_t>(p * 255); break;
        case 1: r = static_cast<uint8_t>(q * 255); g = static_cast<uint8_t>(v * 255); b = static_cast<uint8_t>(p * 255); break;
        case 2: r = static_cast<uint8_t>(p * 255); g = static_cast<uint8_t>(v * 255); b = static_cast<uint8_t>(t * 255); break;
        case 3: r = static_cast<uint8_t>(p * 255); g = static_cast<uint8_t>(q * 255); b = static_cast<uint8_t>(v * 255); break;
        case 4: r = static_cast<uint8_t>(t * 255); g = static_cast<uint8_t>(p * 255); b = static_cast<uint8_t>(v * 255); break;
        case 5: r = static_cast<uint8_t>(v * 255); g = static_cast<uint8_t>(p * 255); b = static_cast<uint8_t>(q * 255); break;
        default: r = g = b = static_cast<uint8_t>(v * 255);
      }
      return Color(r, g, b);
    };

    // --- Логика радуги ---
    static float offset = 0.0;
    offset += speed;  // Прибавляем скорость напрямую (без умножения)

    for (int i = 0; i < it.size(); i++) {
      // Вычисляем позицию в радуге с учётом растяжения
      float pos = (i * stretch * 1.0 / it.size()) + offset;
      float hue = fmod(pos, 1.0);  // Нормализуем в диапазон 0–1

      // Получаем цвет из HSV
      Color rgb = hsv_to_rgb(hue, saturation, 1.0);
      it[i] = rgb;
    }
