addressable_lambda:
  name: "Snow Flakes Parus"
  update_interval: 40ms
  lambda: |-
    // КОНСТАНТЫ
    const int MAX_FLAKES = 15;        // Макс. количество снежинок
    const int SPAWN_RATE = 20;       // Чем меньше — чаще появление (0–100)
    const float MIN_SPEED = 0.3;      // Мин. скорость снежинки (пикселей за шаг)
    const float MAX_SPEED = 3.0;    // Макс. скорость (зависит от слайдера)

    // СТРУКТУРА СНЕЖИНКИ
    static struct {
      float y;           // Позиция (float для плавного движения)
      float vy;          // Скорость (пикселей за шаг)
      bool active;        // Активна?
    } flakes[MAX_FLAKES];

    // СЛАЙДЕРЫ
    int speed_val = id(effect_speed).state;     // 0–255 (скорость)
    int scale_val = id(effect_scale).state;      // 0–100 (количество)
    int intensity = id(effect_intensity).state;   // 0–255 (яркость)

    // 1. ИНИЦИАЛИЗАЦИЯ
    if (initial_run) {
      for (int i = 0; i < MAX_FLAKES; i++) {
        flakes[i].active = false;
      }
    }

    // 2. РАСЧЁТ БАЗОВОЙ СКОРОСТИ (из слайдера)
    float base_speed = MIN_SPEED + (speed_val / 255.0) * (MAX_SPEED - MIN_SPEED);

    // 3. ДВИЖЕНИЕ И ОТРИСОВКА
    for (int i = 0; i < MAX_FLAKES; i++) {
      if (flakes[i].active) {
        flakes[i].y -= flakes[i].vy;  // Движение вниз

        // Отрисовка снежинки (один пиксель)
        int pix = (int)flakes[i].y;
        if (pix >= 0 && pix < it.size()) {
          uint8_t bright = 50 + (intensity / 255.0) * 205;  // Яркость: 50–255
          it[pix] = Color(bright, bright, bright);  // Белый цвет
        }

        // Удаление, если ушла за нижний край
        if (flakes[i].y < 0) {
          flakes[i].active = false;
        }
      }
    }

    // 4. РОЖДЕНИЕ НОВЫХ СНЕЖИНОК
    int num_flakes = (int)((scale_val / 100.0) * MAX_FLAKES) + 1;  // 1–15 снежинок
    int chance = num_flakes * 5;  // Чем больше снежинок — чаще появление

    if ((rand() % 100) < chance) {
      for (int i = 0; i < MAX_FLAKES; i++) {
        if (!flakes[i].active) {
          flakes[i].y = it.size() - 1 + (rand() % 10);  // Старт чуть выше ленты
          flakes[i].vy = base_speed + (rand() % 5) / 10.0;  // Случайная вариация скорости
          flakes[i].active = true;
          break;
        }
      }
    }

    // 5. ОЧИСТКА НЕЗАНЯТЫХ ПИКСЕЛЕЙ
    for (int i = 0; i < it.size(); i++) {
      bool occupied = false;
      for (int j = 0; j < MAX_FLAKES; j++) {
        if (flakes[j].active) {
          int pix = (int)flakes[j].y;
          if (pix == i) {
            occupied = true;
            break;
          }
        }
      }
      if (!occupied) {
        it[i] = Color::BLACK;
      }
    }
