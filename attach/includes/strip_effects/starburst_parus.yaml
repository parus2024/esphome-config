addressable_lambda:
  name: "Starburst Parus"
  update_interval: 50ms
  lambda: |-
    // Максимальное количество звёзд
    static const int MAX_STARS = 3;
    static const int MAX_FRAGMENTS = 6;

    // Структура для описания звезды
    struct Star {
      uint32_t birth_time = 0;  // Время появления
      uint32_t last_time = 0;   // Последнее обновление
      int position = -1;        // Начальная позиция
      int fragments[MAX_FRAGMENTS]; // Позиции фрагментов
      float fragment_velocities[MAX_FRAGMENTS]; // Скорости фрагментов
      uint8_t r, g, b;          // Цвет звезды
    };

    static Star stars[MAX_STARS]; // Массив звёзд
    static uint32_t last_millis = 0;

    // Считываем значения слайдеров
    const int speed_value = id(effect_speed).state;      // 0–255 (скорость появления звёзд)
    const int intensity_value = id(effect_intensity).state; // 0–255 (яркость и длительность следов)
    const int scale_value = id(effect_scale).state;     // 1–100 (количество фрагментов)

    uint32_t now = millis();

    // Вспомогательная функция для получения случайного цвета
    auto get_random_color = []() -> Color {
      uint8_t r = random(256);
      uint8_t g = random(256);
      uint8_t b = random(256);
      return Color(r, g, b);
    };

    // Инициализация при первом запуске
    if (initial_run) {
      for (int i = 0; i < MAX_STARS; i++) {
        stars[i].birth_time = 0;
      }
      last_millis = now;
    }

    // Обработка звёзд
    for (int i = 0; i < MAX_STARS; i++) {
      // Проверка на появление новой звезды
      if (stars[i].birth_time == 0 && random(256) < (speed_value / 4)) {
        stars[i].birth_time = now;
        stars[i].last_time = now;
        stars[i].position = random(it.size());

        // Случайный цвет для звезды
        Color star_color = get_random_color();
        stars[i].r = star_color.r;
        stars[i].g = star_color.g;
        stars[i].b = star_color.b;

        // Инициализация фрагментов
        int num_fragments = 2 + (scale_value / 20); // Количество фрагментов от 2 до 7
        for (int j = 0; j < MAX_FRAGMENTS; j++) {
          stars[i].fragments[j] = (j < num_fragments) ? stars[i].position : -1;
          // Случайные скорости для фрагментов, разные направления
          stars[i].fragment_velocities[j] = (random(256) - 128) / 20.0f;
        }
      }

      // Обновление позиции фрагментов
      if (stars[i].birth_time != 0) {
        float dt = (now - stars[i].last_time) / 1000.0f;
        for (int j = 0; j < MAX_FRAGMENTS; j++) {
          if (stars[i].fragments[j] >= 0) {
            stars[i].fragments[j] += stars[i].fragment_velocities[j] * dt * 50;
            // Проверка границ
            if (stars[i].fragments[j] < 0 || stars[i].fragments[j] >= it.size()) {
              stars[i].fragments[j] = -1;
            }
          }
        }
        stars[i].last_time = now;
      }

      // Отрисовка фрагментов
      if (stars[i].birth_time != 0) {
        uint32_t age = now - stars[i].birth_time;
        float fade = (age > 1500) ? 1.0f : (float)age / 1500.0f;
        if (fade >= 1.0f) {
          stars[i].birth_time = 0; // Звезда исчезла
        } else {
          uint8_t brightness = 255 * (1.0f - fade);
          for (int j = 0; j < MAX_FRAGMENTS; j++) {
            if (stars[i].fragments[j] >= 0 && stars[i].fragments[j] < it.size()) {
              it[stars[i].fragments[j]] = Color(
                (uint8_t)((float)stars[i].r * brightness / 255.0f),
                (uint8_t)((float)stars[i].g * brightness / 255.0f),
                (uint8_t)((float)stars[i].b * brightness / 255.0f)
              );
            }
          }
        }
      }
    }

    last_millis = now;
