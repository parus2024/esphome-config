addressable_lambda:
  name: "Tunnel Parus"
  update_interval: 50ms
  lambda: |-
    // Вспомогательные функции
    auto radians = [](float degrees) -> float {
      return degrees * 3.14159265359f / 180.0f;
    };

    auto beatsin8 = [](uint8_t beats_per_minute, float min_val, float max_val) -> float {
      static uint32_t start_time = millis();
      float t = (millis() - start_time) * beats_per_minute / 60000.0f;
      return (sin(radians(t * 360.0f)) + 1.0f) / 2.0f * (max_val - min_val) + min_val;
    };

    // Считываем значения слайдеров
    const int speed_value = id(effect_speed).state;      // 0–255 (скорость)
    const int scale_value = id(effect_scale).state;      // 1–100 (размер шлейфа)
    const int intensity_value = id(effect_intensity).state; // 0–255 (цвет)

    // Нормализация для расчётов
    const float speed_factor = (float)speed_value / 255.0f * 15.0f + 0.1f; // Скорость движения
    const int trail_decay = 50 + (150 - scale_value); // Динамическое значение для длины шлейфа (от 51 до 150)
    const int pulse_length = 3; // Фиксированная длина импульса

    // Статические переменные для импульсов
    static unsigned int PulseArray[][3] = {
      {0, 10, 30},  // {позиция, скорость, базовая амплитуда}
      {0, 20, 50}
    };
    static unsigned int Resolution = 100;
    static unsigned int TotalPulses = sizeof(PulseArray) / sizeof(PulseArray[0]);

    // Затемнение (шлейф) — уменьшаем яркость всех светодиодов
    for (int i = 0; i < it.size(); i++) {
      it[i].fade_to_black(trail_decay);
    }

    // Обработка каждого импульса
    for (int ThisPulse = 0; ThisPulse < TotalPulses; ThisPulse++) {
      // Колебание позиции
      float beat = beatsin8(15 + ThisPulse * 5, -1.0f, 1.0f);
      int oscillation = (int)(beat * (float)PulseArray[ThisPulse][2]);

      // Текущая высокоточная позиция
      int DeltaHiResPos = PulseArray[ThisPulse][0] + oscillation;
      int DeltaLEDPos = DeltaHiResPos / Resolution;

      // Формируем цвет на основе intensity_value
      uint8_t r, g, b;
      if (intensity_value == 0) {
        r = g = b = 255; // Белый цвет при intensity_value = 0
      } else if (intensity_value < 85) {
        r = 255;
        g = (uint8_t)(intensity_value * 3);
        b = 0;
      } else if (intensity_value < 170) {
        r = (uint8_t)(255 - (intensity_value - 85) * 3);
        g = 255;
        b = 0;
      } else {
        r = 0;
        g = 255;
        b = (uint8_t)((intensity_value - 170) * 3);
      }

      Color pulse_color = Color(r, g, b);

      // Рисуем импульс с отражением
      for (int i = 0; i < pulse_length; i++) {
        int pos = DeltaLEDPos + i;

        // Отражение от левого края
        if (pos < 0) pos = -pos;

        // Циклическое повторение (лента как кольцо)
        pos = pos % (it.size() * 2);

        // Отражение от правого края
        if (pos >= it.size()) {
          pos = it.size() * 2 - pos - 1;
        }

        it[pos] = pulse_color;
      }

      // Движение импульса вперёд
      PulseArray[ThisPulse][0] += (unsigned int)(PulseArray[ThisPulse][1] * speed_factor);

      // Сброс позиции при выходе за пределы
      if (PulseArray[ThisPulse][0] > (it.size() * Resolution * 2)) {
        PulseArray[ThisPulse][0] = 0;
      }
    }
