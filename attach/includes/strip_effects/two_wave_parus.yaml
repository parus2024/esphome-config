addressable_lambda:
  name: "Two Wave Parus"
  update_interval: 20ms
  lambda: |-
    // Вспомогательные лямбда-функции
    auto radians = [](float degrees) -> float {
      return degrees * 3.14159265359f / 180.0f;
    };

    auto clamp = [](float value, float min_val, float max_val) -> float {
      return value < min_val ? min_val : (value > max_val ? max_val : value);
    };

    auto hsv_to_rgb = [&](float h, float s, float v, uint8_t& r, uint8_t& g, uint8_t& b) {
      h = fmod(h, 360.0f);
      s = clamp(s, 0.0f, 1.0f);
      v = clamp(v, 0.0f, 1.0f);

      float c = v * s;
      float x = c * (1.0f - abs(fmod(h / 60.0f, 2.0f) - 1.0f));
      float m = v - c;

      float rf = 0.0f, gf = 0.0f, bf = 0.0f;
      if (h >= 0.0f && h < 60.0f) {
        rf = c; gf = x; bf = 0.0f;
      } else if (h >= 60.0f && h < 120.0f) {
        rf = x; gf = c; bf = 0.0f;
      } else if (h >= 120.0f && h < 180.0f) {
        rf = 0.0f; gf = c; bf = x;
      } else if (h >= 180.0f && h < 240.0f) {
        rf = 0.0f; gf = x; bf = c;
      } else if (h >= 240.0f && h < 300.0f) {
        rf = x; gf = 0.0f; bf = c;
      } else {
        rf = c; gf = 0.0f; bf = x;
      }

      r = (uint8_t)((rf + m) * 255.0f);
      g = (uint8_t)((gf + m) * 255.0f);
      b = (uint8_t)((bf + m) * 255.0f);
    };

    // Статические переменные
    static float this_phase = 0.0f;
    static float that_phase = 0.0f;
    static float this_hue = 0.0f;
    static float that_hue = 180.0f;
    static int variant = -1;

    // Получаем значения слайдеров
    const uint8_t SPEED = id(effect_speed).state;      // 0–255: скорость
    const uint8_t SCALE = id(effect_scale).state;      // 0–100: частота волн
    const uint8_t INTENSITY = id(effect_intensity).state; // 0–255: яркость

    if (initial_run) {
      ESP_LOGD("effect", "Custom TwoSin Improved - Initialized");
      variant = -1;
    }

    // Изменение параметров в зависимости от значения SCALE (0-100)
    if (variant != SCALE) {
      if (SCALE >= 84) {
        this_hue = 0.0f;
        that_hue = 128.0f;
      } else if (SCALE >= 68) {
        this_hue = 64.0f;
        that_hue = 192.0f;
      } else if (SCALE >= 52) {
        this_hue = 96.0f;
        that_hue = 224.0f;
      } else if (SCALE >= 36) {
        this_hue = 24.0f;
        that_hue = 180.0f;
      } else if (SCALE >= 20) {
        this_hue = 48.0f;
        that_hue = 160.0f;
      } else {
        this_hue = 96.0f;
        that_hue = 224.0f;
      }
      variant = SCALE;
    }

    // Нормализуем параметры
    float wave_speed = 0.1f + (SPEED / 255.0f) * 2.0f;
    float frequency = 0.1f + (SCALE / 100.0f) * 2.0f; // Частота волн от 0.1 до 2.1
    float brightness_factor = INTENSITY / 255.0f;
    float cutoff = 128.0f * (1.0f - brightness_factor);

    // Обновляем фазы
    this_phase += wave_speed * 1.0f;
    that_phase += wave_speed * -0.7f;

    // Плавно меняем оттенки
    this_hue = fmod(this_hue + 0.5f, 360.0f);
    that_hue = fmod(that_hue - 0.3f, 360.0f);

    // Основной цикл
    for (int i = 0; i < it.size(); i++) {
      float pos_this = (float)i * frequency + this_phase;
      float pos_that = (float)i * frequency + that_phase + 180.0f;

      // Синусоидальная яркость с использованием кубической интерполяции для плавности
      float bright_this = 0.5f + 0.5f * sin(radians(pos_this));
      bright_this = bright_this * bright_this; // Кубическая интерполяция для более резких переходов
      float bright_that = 0.5f + 0.5f * sin(radians(pos_that));
      bright_that = bright_that * bright_that;

      // Порог яркости
      bright_this = bright_this > (cutoff / 255.0f) ? bright_this : 0.0f;
      bright_that = bright_that > (cutoff / 255.0f) ? bright_that : 0.0f;

      // RGB для каждой волны
      uint8_t r1 = 0, g1 = 0, b1 = 0;
      hsv_to_rgb(this_hue, 1.0f, bright_this * brightness_factor, r1, g1, b1);

      uint8_t r2 = 0, g2 = 0, b2 = 0;
      hsv_to_rgb(that_hue, 1.0f, bright_that * brightness_factor, r2, g2, b2);

      // Смешение цветов
      uint8_t r = (uint8_t)min(255, (int)r1 + (int)r2);
      uint8_t g = (uint8_t)min(255, (int)g1 + (int)g2);
      uint8_t b = (uint8_t)min(255, (int)b1 + (int)b2);

      it[i] = Color(r, g, b);
    }
