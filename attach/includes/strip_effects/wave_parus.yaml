addressable_lambda:
  name: "Wave Parus"
  update_interval: 75ms
  lambda: |-
    static float wave_position = 0.0;

    // Получаем значения со слайдеров
    const uint8_t SPEED = static_cast<uint8_t>(id(effect_speed).state);      // 0–255
    const uint8_t COLOR_OFFSET = static_cast<uint8_t>(id(effect_scale).state); // 0–255 (управляет цветами)
    const uint8_t INTENSITY = static_cast<uint8_t>(id(effect_intensity).state); // 0–255

    // Нормализуем значения
    float wave_speed = SPEED / 255.0 * 2.0; // Скорость: 0.0–2.0
    int x = INTENSITY / 4 + 1; // Ширина пика волны (1–64)
    int y = INTENSITY / 2 + 1; // Расстояние между волнами (1–128)

    // Функция для получения цвета из градиента
    auto get_gradient_color = [](float position) -> Color {
      // Градиент: 0–255 → плавный переход между парами оттенков
      float segment = 255.0 / 12.0; // 12 сегментов для разнообразия
      float pos = position / 255.0;

      // Определяем пару оттенков в зависимости от позиции
      if (pos < 1.0/12.0) { // Розовый-белый
        float ratio = pos * 12.0;
        return Color(
          255 * (1.0 - ratio) + 255 * ratio,
          255 * (1.0 - ratio) + 200 * ratio,
          255 * (1.0 - ratio) + 220 * ratio
        );
      }
      else if (pos < 2.0/12.0) { // Розовый-сиреневый
        float ratio = (pos - 1.0/12.0) * 12.0;
        return Color(
          255 * (1.0 - ratio) + 220 * ratio,
          200 * (1.0 - ratio) + 180 * ratio,
          220 * (1.0 - ratio) + 200 * ratio
        );
      }
      else if (pos < 3.0/12.0) { // Красный-жёлтый
        float ratio = (pos - 2.0/12.0) * 12.0;
        return Color(
          255 * (1.0 - ratio) + 255 * ratio,
          50 * (1.0 - ratio) + 200 * ratio,
          50 * (1.0 - ratio) + 50 * ratio
        );
      }
      else if (pos < 4.0/12.0) { // Голубой-светло-зелёный
        float ratio = (pos - 3.0/12.0) * 12.0;
        return Color(
          50 * (1.0 - ratio) + 100 * ratio,
          200 * (1.0 - ratio) + 220 * ratio,
          255 * (1.0 - ratio) + 150 * ratio
        );
      }
      else if (pos < 5.0/12.0) { // Синий-фиолетовый
        float ratio = (pos - 4.0/12.0) * 12.0;
        return Color(
          100 * (1.0 - ratio) + 150 * ratio,
          100 * (1.0 - ratio) + 50 * ratio,
          255 * (1.0 - ratio) + 200 * ratio
        );
      }
      else if (pos < 6.0/12.0) { // Зелёный-салатовый
        float ratio = (pos - 5.0/12.0) * 12.0;
        return Color(
          50 * (1.0 - ratio) + 150 * ratio,
          200 * (1.0 - ratio) + 220 * ratio,
          50 * (1.0 - ratio) + 100 * ratio
        );
      }
      else if (pos < 7.0/12.0) { // Оранжевый-персиковый
        float ratio = (pos - 6.0/12.0) * 12.0;
        return Color(
          255 * (1.0 - ratio) + 255 * ratio,
          150 * (1.0 - ratio) + 200 * ratio,
          50 * (1.0 - ratio) + 150 * ratio
        );
      }
      else if (pos < 8.0/12.0) { // Жёлтый-золотистый
        float ratio = (pos - 7.0/12.0) * 12.0;
        return Color(
          255 * (1.0 - ratio) + 255 * ratio,
          255 * (1.0 - ratio) + 220 * ratio,
          50 * (1.0 - ratio) + 100 * ratio
        );
      }
      else if (pos < 9.0/12.0) { // Серый-голубой
        float ratio = (pos - 8.0/12.0) * 12.0;
        return Color(
          150 * (1.0 - ratio) + 100 * ratio,
          150 * (1.0 - ratio) + 150 * ratio,
          150 * (1.0 - ratio) + 200 * ratio
        );
      }
      else if (pos < 10.0/12.0) { // Сиреневый-лавандовый
        float ratio = (pos - 9.0/12.0) * 12.0;
        return Color(
          200 * (1.0 - ratio) + 220 * ratio,
          150 * (1.0 - ratio) + 200 * ratio,
          200 * (1.0 - ratio) + 220 * ratio
        );
      }
      else if (pos < 11.0/12.0) { // Бирюзовый-мятный
        float ratio = (pos - 10.0/12.0) * 12.0;
        return Color(
          50 * (1.0 - ratio) + 150 * ratio,
          200 * (1.0 - ratio) + 220 * ratio,
          200 * (1.0 - ratio) + 200 * ratio
        );
      }
      else { // Белый-тёплый белый
        float ratio = (pos - 11.0/12.0) * 12.0;
        return Color(
          255 * (1.0 - ratio) + 255 * ratio,
          255 * (1.0 - ratio) + 240 * ratio,
          255 * (1.0 - ratio) + 230 * ratio
        );
      }
    };

    // Получаем два цвета из градиента (смещённые на 1/3 для контраста)
    Color color1 = get_gradient_color(COLOR_OFFSET);
    Color color2 = get_gradient_color(COLOR_OFFSET + 85); // Смещение на 1/3 от 255

    // Основной цикл эффекта
    wave_position += wave_speed;
    if (wave_position >= (x + y)) {
      wave_position -= (x + y);
    }

    for (int i = 0; i < it.size(); i++) {
      float forward_position_in_wave = fmod(i + wave_position, x + y);
      float forward_brightness = 0.0;
      if (forward_position_in_wave < x) {
        forward_brightness = (1.0 - fabs((forward_position_in_wave / x) * 2.0 - 1.0));
      }

      float backward_position_in_wave = fmod(it.size() - 1 - i + wave_position, x + y);
      float backward_brightness = 0.0;
      if (backward_position_in_wave < x) {
        backward_brightness = (1.0 - fabs((backward_position_in_wave / x) * 2.0 - 1.0));
      }

      uint8_t r = std::min(255, static_cast<int>((color1.red   * forward_brightness) + (color2.red   * backward_brightness)));
      uint8_t g = std::min(255, static_cast<int>((color1.green * forward_brightness) + (color2.green * backward_brightness)));
      uint8_t b = std::min(255, static_cast<int>((color1.blue  * forward_brightness) + (color2.blue  * backward_brightness)));

      it[i] = Color(r, g, b);
    }
