substitutions:
  name: stellage1
  friendly_name: Stellage 1
  friendly_name_short: stellage1
  version: '02.02.2026'
  device_ip: 192.168.0.88
  reboot_timeout: 20min
  sda1: GPIO4
  scl1: GPIO5
  encoder_button_pin: GPIO0
  pin_a: GPIO1
  pin_b: GPIO3
  shelf1_pin: GPIO12
  shelf2_pin: GPIO13
  shelf3_pin: GPIO14
  shelf4_pin: GPIO15
  status_led_pin: GPIO2
  fan_pin: GPIO16

#<<: !include attach/common/esphome.yaml
<<: !include attach/common/esp/8266_nodemcuv2_restore.yaml
<<: !include attach/common/logger/debug_component_error.yaml
<<: !include attach/common/api.yaml
<<: !include attach/common/ota.yaml
<<: !include attach/common/wifi.yaml
<<: !include attach/common/web/web_server3_climate.yaml
<<: !include attach/common/bus/i2c_a.yaml

packages:
  common: !include attach/packages/standart.yaml
  time_sun: !include attach/packages/time_sun.yaml
esphome:
  name: ${name}
  friendly_name: ${friendly_name}
  name_add_mac_suffix: false
  project:
    name: esphome.Stellage3
    version: ${version}
  on_boot:
    - priority: -100.0
      then:
        - delay: 2s
        - lambda: |-
            if (id(shelf1_state) && !id(shelf1).state && id(auto_mode).state) {  // Проверяем состояние globals 'shelf1_state'
              id(shelf1).turn_on();  // Включаем полку 1
            } else {
              //id(shelf1).turn_off();
            }
        - lambda: |-
            if (id(shelf2_state) && !id(shelf2).state && id(auto_mode).state) {  // Проверяем состояние globals 'shelf2_state'
              id(shelf2).turn_on();  // Включаем полку 2
            } else {
              //id(shelf2).turn_off();
            }
        - lambda: |-
            if (id(shelf3_state) && !id(shelf3).state && id(auto_mode).state) {  // Проверяем состояние globals 'shelf3_state'
              id(shelf3).turn_on();  // Включаем полку 3
            } else {
              //id(shelf3).turn_off();
            }
        - lambda: |-
            if (id(shelf4_state) && !id(shelf4).state && id(auto_mode).state) {  // Проверяем состояние globals 'shelf4_state'
              id(shelf4).turn_on();  // Включаем полку 4
            } else {
              //id(shelf4).turn_off();
            }

globals:
  - id: shelf1_state
    type: bool
    restore_value: yes
    initial_value: 'false'
  - id: shelf2_state
    type: bool
    restore_value: yes
    initial_value: 'false'
  - id: shelf3_state
    type: bool
    restore_value: yes
    initial_value: 'false'
  - id: shelf4_state
    type: bool
    restore_value: yes
    initial_value: 'false'
  - id: is_updating_from_number
    type: bool
    initial_value: "false"
light:
  - platform: status_led
    name: "Status led"
    id: state_led
    pin:
      number: ${status_led_pin}
      inverted: true
fan:
  - platform: speed
    output: fan_output
    name: "Fan"
    id: my_fan
    speed_count: 3
    restore_mode: RESTORE_DEFAULT_OFF
#    on_state:
#      lambda: |-
#        if (id(fan_speed).state == 0) {
#          id(my_fan).turn_off();
#        }

output:
  - platform: esp8266_pwm
    pin: ${fan_pin}
    frequency: 10 Hz
    id: fan_output
font:
  - file: "fonts/arial.ttf"
    id: arial_12
    size: 12
    glyphs: |-
      #~*<>!'"%/()+=,-_.:°0123456789АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЬЫЪЭЮЯABCDEFGHIJKLMNOPQRSTUVWXYZ абвгдеёжзийклмнопрстуфхцчшщьыъэюяabcdefghijklmnopqrstuvwxyz
  - file: "fonts/arial.ttf"
    id: arial_36
    size: 36
    glyphs: |-
      : 0123456789

switch:
  - platform: gpio
    name: "Shelf 1"
    pin: ${shelf1_pin}
    id: shelf1
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_off: 
      then:
        - globals.set:
            id: shelf1_state
            value: "false"
  - platform: gpio
    name: "Shelf 2"
    pin: ${shelf2_pin}
    id: shelf2
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_off: 
      then:
        - globals.set:
            id: shelf2_state
            value: "false"
  - platform: gpio
    name: "Shelf 3"
    pin: ${shelf3_pin}
    id: shelf3
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_off: 
      then:
        - globals.set:
            id: shelf3_state
            value: "false"
  - platform: gpio
    name: "Shelf 4"
    pin: ${shelf4_pin}
    id: shelf4
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_off: 
      then:
        - globals.set:
            id: shelf4_state
            value: "false"
  - platform: template
    name: "Auto Mode"
    id: auto_mode
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

text_sensor:
  - platform: debug
    device:
      name: "Device Info"
    reset_reason:
      name: "Reset Reason"
sensor:
  - platform: debug
    free:
      name: "Heap Free"
    fragmentation:
      name: "Heap Fragmentation"
    block:
      name: "Heap Max Block"
    loop_time:
      name: "Loop Time"
# Encoder
  - platform: rotary_encoder
    name: "Encoder"
    id: my_encoder
    pin_a: 
      number: ${pin_a}
      inverted: false
    pin_b:
      number: ${pin_b}
      inverted: false
    min_value: 0
    max_value: 100
    resolution: 1
    publish_initial_value: true
    restore_mode: RESTORE_DEFAULT_ZERO
#    filters:
#    - or:
#        - debounce: 0.05s
    on_clockwise:
      - if:
          condition:
            display_menu.is_active: my_menu
          then:
            - display_menu.down: my_menu
      - if:
          condition:
            - display.is_displaying_page:
                id: my_display
                page_id: screensaver
          then:
            - number.set:
                id: brightness
                value: !lambda 'return id(my_encoder).state;'
                
    on_anticlockwise:
      - if:
          condition:
            display_menu.is_active: my_menu
          then:
            - display_menu.up: my_menu
      - if:
          condition:
            - display.is_displaying_page:
                id: my_display
                page_id: screensaver
          then:
            - number.set:
                id: brightness
                value: !lambda 'return id(my_encoder).state;'
safe_mode:

display:
  - platform: ssd1306_i2c
    model: "SSD1306 128x64"
    address: 0x3C
    id: my_display
#    rotation: 90
    pages:
      - id: screensaver 
        lambda: |-
          it.print(2, 0, id(arial_12), TextAlign::TOP_LEFT, "PARUS SMART HOME");
          it.printf(0, 14, id(arial_12), "Вкл %02d:%02d Выкл %02d:%02d", id(datetime_on).hour, id(datetime_on).minute, id(datetime_off).hour, id(datetime_off).minute);
          it.strftime(15, 30, id(arial_36), TextAlign::TOP_LEFT, "%H:%M", id(sntp_time).now());

number:
  - platform: template
    name: "Hour to ON" # Установка часов на включение
    id: hour_to_on
    optimistic: true
    min_value: 0
    max_value: 23
    initial_value: 7
    step: 1
    restore_value: true
    on_value:
      then:
        - globals.set:
            id: is_updating_from_number
            value: "true"
        - datetime.time.set:
            id: datetime_on
            time: !lambda |-
              return {.second = 0, .minute = id(datetime_on).minute, .hour = static_cast<uint8_t>(id(hour_to_on).state)};
        - globals.set:
            id: is_updating_from_number
            value: "false"
  - platform: template
    name: "Minute to ON" # Установка минут на включение
    id: minute_to_on
    optimistic: true
    min_value: 0
    max_value: 60
    initial_value: 0
    step: 1
    restore_value: true
    on_value:
      then:
        - globals.set:
            id: is_updating_from_number
            value: "true"
        - datetime.time.set:
            id: datetime_on
            time: !lambda |-
              return {.second = 0, .minute = static_cast<uint8_t>(id(minute_to_on).state), .hour = id(datetime_on).hour};
        - globals.set:
            id: is_updating_from_number
            value: "false"
  - platform: template
    name: "Hour to OFF" # Установка часов на выключение
    id: hour_to_off
    optimistic: true
    min_value: 0
    max_value: 24
    initial_value: 23
    step: 1
    restore_value: true
    on_value:
      then:
        - globals.set:
            id: is_updating_from_number
            value: "true"
        - datetime.time.set:
            id: datetime_off
            time: !lambda |-
              return {.second = 0, .minute = id(datetime_off).minute, .hour = static_cast<uint8_t>(id(hour_to_off).state)};
        - globals.set:
            id: is_updating_from_number
            value: "false"  
  - platform: template
    name: "Minute to OFF" # Установка минут на выключение
    id: minute_to_off
    optimistic: true
    min_value: 0
    max_value: 60
    initial_value: 0
    step: 1
    restore_value: true
    on_value:
      then:
        - globals.set:
            id: is_updating_from_number
            value: "true"
        - datetime.time.set:
            id: datetime_off
            time: !lambda |-
              return {.second = 0, .minute = static_cast<uint8_t>(id(minute_to_off).state), .hour = id(datetime_off).hour};
        - globals.set:
            id: is_updating_from_number
            value: "false"  
  - platform: template
    name: "Brightness" # Установка яркости
    id: brightness
    optimistic: true
    min_value: 0
    max_value: 100
    step: 20
    initial_value: 80
    restore_value: true
    on_value:
      then:
        lambda: |-
          id(my_display).set_contrast(x / 100.0);
  - platform: template
    name: "Fan Speed" # Установка скорости вентилятора
    id: fan_speed
    optimistic: true
    min_value: 0
    max_value: 3
    step: 1
    restore_value: true
    on_value:
      then:
        - lambda: |-
            if (x == 0) {
              auto call = id(my_fan).turn_off();
              call.perform();
            } else {
              auto call = id(my_fan).turn_on();
              call.set_speed(x);
              call.perform();
            }
  - platform: template
    name: "Fan frequency" # Установка частоты
    id: fan_frequency
    optimistic: true
    min_value: 10
    max_value: 10000
    step: 100
    restore_value: true
    on_value:
      then:
        - output.esp8266_pwm.set_frequency:
            id: fan_output
            frequency:  !lambda 'return id(fan_frequency).state;'

debug:
  update_interval: 60s

datetime:
  # Example DateTime
  - platform: template
    id: datetime_on
#    time_id: my_time
    type: time
    name: "To ON"
    optimistic: yes
    initial_value: "07:00:00"
    restore_value: true
    on_value:
      then:
        - if:
            condition:
              lambda: 'return !id(is_updating_from_number);'
            then:
              - number.set:
                  id: hour_to_on
                  value: !lambda 'return x.hour;'
              - number.set:
                  id: minute_to_on
                  value: !lambda 'return x.minute;'
    on_time:
      then:
        - lambda: |-
            if (id(shelf1_state) && !id(shelf1).state && id(auto_mode).state) {  // Проверяем состояние globals 'shelf1_state'
              id(shelf1).turn_on();  // Включаем полку 1
            } else {
              //id(shelf1).turn_off();
            }
        - lambda: |-
            if (id(shelf2_state) && !id(shelf2).state  && id(auto_mode).state) {  // Проверяем состояние globals 'shelf2_state'
              id(shelf2).turn_on();  // Включаем полку 2
            } else {
              //id(shelf2).turn_off();
            }
        - lambda: |-
            if (id(shelf3_state) && !id(shelf3).state && id(auto_mode).state) {  // Проверяем состояние globals 'shelf3_state'
              id(shelf3).turn_on();  // Включаем полку 3
            } else {
              //id(shelf3).turn_off();
            }
        - lambda: |-
            if (id(shelf4_state) && !id(shelf4).state && id(auto_mode).state) {  // Проверяем состояние globals 'shelf4_state'
              id(shelf4).turn_on();  // Включаем полку 4
            } else {
              //id(shelf4).turn_off();
            }
  - platform: template
    id: datetime_off
#    time_id: my_time
    type: time
    name: "To OFF"
    optimistic: yes
    initial_value: "23:00:00"
    restore_value: true
    on_value:
      then:
        - if:
            condition:
              lambda: 'return !id(is_updating_from_number);'
            then:
              - number.set:
                  id: hour_to_off
                  value: !lambda 'return x.hour;'
              - number.set:
                  id: minute_to_off
                  value: !lambda 'return x.minute;'
    on_time:
      then:
        - globals.set:
            id: shelf1_state
            value: !lambda 'return id(shelf1).state;'
        - globals.set:
            id: shelf2_state
            value: !lambda 'return id(shelf2).state;'
        - globals.set:
            id: shelf3_state
            value: !lambda 'return id(shelf3).state;'
        - globals.set:
            id: shelf4_state
            value: !lambda 'return id(shelf4).state;'
        - delay: 1s
        - if:
            condition:
              switch.is_on: auto_mode
            then:
              - switch.turn_off: shelf1
              - switch.turn_off: shelf2
              - switch.turn_off: shelf3
              - switch.turn_off: shelf4
graphical_display_menu:
  id: my_menu
  display: my_display
  on_redraw:
    then:
      component.update: my_display
  active: false
  mode: rotary
  font: arial_12
  items:
    - type: command
      text: 'Выход из меню'
      on_value:
        then:
          - display_menu.hide: my_menu
    - type: switch
      immediate_edit: false
      text: 'Полка 1'
      on_text: 'Вкл'
      off_text: 'Выкл'
      switch: shelf1
#      on_enter:
#        then:
#          lambda: 'ESP_LOGI("my_menu", "switch enter: %s, %s", it->get_text().c_str(), it->get_value_text().c_str());'
#      on_leave:
#        then:
#          lambda: 'ESP_LOGI("my_menu", "switch leave: %s, %s", it->get_text().c_str(), it->get_value_text().c_str());'
#      on_value:
#        then:
#          lambda: 'ESP_LOGI("my_menu", "switch value: %s, %s", it->get_text().c_str(), it->get_value_text().c_str());'
    - type: switch
      immediate_edit: false
      text: 'Полка 2'
      on_text: 'Вкл'
      off_text: 'Выкл'
      switch: shelf2
#      on_enter:
#        then:
#          lambda: 'ESP_LOGI("my_menu", "switch enter: %s, %s", it->get_text().c_str(), it->get_value_text().c_str());'
#      on_leave:
#        then:
#          lambda: 'ESP_LOGI("my_menu", "switch leave: %s, %s", it->get_text().c_str(), it->get_value_text().c_str());'
#      on_value:
#        then:
#          lambda: 'ESP_LOGI("my_menu", "switch value: %s, %s", it->get_text().c_str(), it->get_value_text().c_str());'
    - type: switch
      immediate_edit: false
      text: 'Полка 3'
      on_text: 'Вкл'
      off_text: 'Выкл'
      switch: shelf3
#      on_enter:
#        then:
#          lambda: 'ESP_LOGI("my_menu", "switch enter: %s, %s", it->get_text().c_str(), it->get_value_text().c_str());'
#      on_leave:
#        then:
#          lambda: 'ESP_LOGI("my_menu", "switch leave: %s, %s", it->get_text().c_str(), it->get_value_text().c_str());'
#      on_value:
#        then:
#          lambda: 'ESP_LOGI("my_menu", "switch value: %s, %s", it->get_text().c_str(), it->get_value_text().c_str());'
    - type: switch
      immediate_edit: false
      text: 'Полка 4'
      on_text: 'Вкл'
      off_text: 'Выкл'
      switch: shelf4
#      on_enter:
#        then:
#          lambda: 'ESP_LOGI("my_menu", "switch enter: %s, %s", it->get_text().c_str(), it->get_value_text().c_str());'
#      on_leave:
#        then:
#          lambda: 'ESP_LOGI("my_menu", "switch leave: %s, %s", it->get_text().c_str(), it->get_value_text().c_str());'
#      on_value:
#        then:
#          lambda: 'ESP_LOGI("my_menu", "switch value: %s, %s", it->get_text().c_str(), it->get_value_text().c_str());'
    - type: number
      text: 'Режим кулера'
      format: '%.2f'
      number: fan_speed
#      on_enter:
#        then:
#          lambda: 'ESP_LOGI("display_menu", "number enter: %s, %s", it->get_text().c_str(), it->get_value_text().c_str());'
#      on_leave:
#        then:
#          lambda: 'ESP_LOGI("display_menu", "number leave: %s, %s", it->get_text().c_str(), it->get_value_text().c_str());'
#      on_value:
#        then:
#          lambda: 'ESP_LOGI("display_menu", "number value: %s, %s", it->get_text().c_str(), it->get_value_text().c_str());'
    - type: menu
      text: 'Выбор ВРЕМЕНИ'
      items:
        - type: number
          text: 'ЧАСЫ ВКЛ'
          format: '%.2f'
          number: hour_to_on
#          on_enter:
#            then:
#              lambda: 'ESP_LOGI("display_menu", "number enter: %s, %s", it->get_text().c_str(), it->get_value_text().c_str());'
#          on_leave:
#            then:
#              lambda: 'ESP_LOGI("display_menu", "number leave: %s, %s", it->get_text().c_str(), it->get_value_text().c_str());'
#          on_value:
#            then:
#              lambda: 'ESP_LOGI("display_menu", "number value: %s, %s", it->get_text().c_str(), it->get_value_text().c_str());'
        - type: number
          text: 'ЧАСЫ ВЫКЛ'
          format: '%.2f'
          number: hour_to_off
#          on_enter:
#            then:
#              lambda: 'ESP_LOGI("display_menu", "number enter: %s, %s", it->get_text().c_str(), it->get_value_text().c_str());'
#          on_leave:
#            then:
#              lambda: 'ESP_LOGI("display_menu", "number leave: %s, %s", it->get_text().c_str(), it->get_value_text().c_str());'
#          on_value:
#            then:
#              lambda: 'ESP_LOGI("display_menu", "number value: %s, %s", it->get_text().c_str(), it->get_value_text().c_str());'
        - type: back
          text: Back

binary_sensor:
  - platform: gpio
    pin:
      number: ${encoder_button_pin} # Вход кнопки энкодера
      inverted: true
    name: "Encoder Button"
    id: encoder_button
    on_multi_click:

#    - timing: # Одиночное длительное нажатие
#        - ON for 1s to 3s
#        - OFF for at least 0.5s
#      then:
#        - if:
#            condition:
#              display.is_displaying_page: page1
#            then:  
#              - switch.toggle: shelf1
#            else:
#              - if:
#                  condition:
#                    lambda: 'return (!id(my_menu).is_active());'
#                  then:
#                    - display.page.show: screensaver
    - timing: # Одиночное короткое нажатие
        - ON for at most 1s
        - OFF for at least 0.5s
      then:
        - if:
            condition:
              display_menu.is_active: my_menu
            then:
              - display_menu.enter: my_menu
            else:
              - display.page.show_next: my_display
    - timing:  # Двойное нажатие
        - ON for at most 1s
        - OFF for at most 1s
        - ON for at most 1s
        - OFF for at least 0.2s
      then:
        - if:
            condition:
              lambda: 'return (!id(my_menu).is_active());'
            then:
              - display_menu.show_main: my_menu
            else:
              - display_menu.hide: my_menu
button:
  - platform: template
    id: glogals_show_button
    icon: mdi:autorenew
    name: "Globals Button"
    on_press: 
      then:
        - lambda: |-
            ESP_LOGD("globals", "Shelf1_state: %s", id(shelf1_state) ? "true" : "false");
            ESP_LOGD("globals", "Shelf2_state: %s", id(shelf2_state) ? "true" : "false");
            ESP_LOGD("globals", "Shelf3_state: %s", id(shelf3_state) ? "true" : "false");
            ESP_LOGD("globals", "Shelf4_state: %s", id(shelf4_state) ? "true" : "false");
interval:
  - interval: 300s  # Заставка при бездействии
    then:
      - if:
          condition:
            for:
              time: 5min
              condition:
                - binary_sensor.is_off: encoder_button
                - display_menu.is_active: my_menu
          then:
            - display_menu.hide: my_menu
            - display.page.show: screensaver
            - lambda: |-
                id(my_display).set_contrast(0.1);
